# Behavior Tree Studio V1 — Implementation Plan

> Based on [formal-specs-for-v1.md](../requirements-definition/studio/formal-specs-for-v1.md)

---

## Phase 1: Core Runtime Prerequisites

- [ ] **Completed**

### Goal

Add `useNowAsTickId()` to `BehaviourTree` and modify `enableProfiling`/`disableProfiling` to support cached time provider re-enable — both are prerequisites required by the spec (Section 6.0).

### Current State

- `BehaviourTree.tick()` auto-increments `currentTickId` from 1. The spec requires a mode where `tickId` is sourced from `now`.
- `enableProfiling(getTime)` always requires the `getTime` argument. `disableProfiling()` sets `profilingTimeProvider = undefined`, destroying the cached provider. The spec requires subsequent `enableProfiling()` calls to reuse a cached provider.

### What to Implement

#### 1.1 `BehaviourTree.useNowAsTickId()`

Add to `BehaviourTree`:

- Private field: `private useNowAsTickIdEnabled = false`
- Private field: `private lastNowTickId: number | undefined` (tracks last accepted `now` for duplicate/regression detection)
- Public method: `useNowAsTickId(): BehaviourTree` — enables the mode, returns `this` for chaining
- In `tick()`: when `useNowAsTickIdEnabled` is true:
  - `now` parameter becomes **required** (throw if undefined)
  - Set `tickId = now` instead of `this.currentTickId`
  - Validate: if `lastNowTickId !== undefined && now <= lastNowTickId`, throw an error with a descriptive message (duplicate/older now rejected)
  - Update `lastNowTickId = now` after successful validation
  - Skip the `this.currentTickId++` increment

#### 1.2 Modify `enableProfiling` / `disableProfiling`

Add to `BehaviourTree`:

- Private field: `private cachedProfilingTimeProvider: (() => number) | undefined`
- Change `enableProfiling(getTime?: () => number)`:
  - If `getTime` is provided: set both `profilingTimeProvider` and `cachedProfilingTimeProvider`
  - If `getTime` is omitted: use `cachedProfilingTimeProvider` as `profilingTimeProvider`; throw if `cachedProfilingTimeProvider` is also undefined (first call must provide it)
- Change `disableProfiling()`:
  - Set `profilingTimeProvider = undefined` (disables profiling)
  - **Keep** `cachedProfilingTimeProvider` intact for later re-enable

### Files to Modify

| File | Changes |
|------|---------|
| `packages/core/src/tree.ts` | Add `useNowAsTickIdEnabled`, `lastNowTickId`, `cachedProfilingTimeProvider` fields. Add `useNowAsTickId()` method. Modify `tick()`, `enableProfiling()`, `disableProfiling()`. |

### Tests to Write

In `packages/core/src/tree.test.ts`:

**`useNowAsTickId()` tests:**
- When enabled, `tickId` equals the provided `now` value
- Rejects duplicate `now` (same value as previous tick) with error
- Rejects older `now` (lower than previous tick) with error
- Accepts strictly increasing `now` values
- Throws when `now` is not provided while mode is enabled
- Does not interfere with auto-increment mode when not enabled

**`enableProfiling` caching tests:**
- First `enableProfiling()` without `getTime` throws (no cached provider)
- `enableProfiling(getTime)` then `disableProfiling()` then `enableProfiling()` (no arg) succeeds — reuses cached provider
- Profiling is active after re-enable (events include `startedAt`/`finishedAt`)
- Providing a new `getTime` on re-enable replaces the cached provider

### Verification

```bash
yarn test packages/core/src/tree.test.ts
yarn typecheck
yarn lint
```

---

## Phase 2: Protocol Types & Package Scaffolding (`studio-transport`)

- [ ] **Completed**

### Goal

Create the `@behavior-tree-ist/studio-transport` package with protocol message types, numeric message type constants, command types, error codes, and treeId validation.

### What to Implement

#### 2.1 Package Scaffolding

Create a new package at `packages/studio-transport/` with:
- `package.json` — name `@behavior-tree-ist/studio-transport`, peer dep on `@behavior-tree-ist/core`, build with tsup
- `tsconfig.json` — extending root tsconfig pattern
- `tsup.config.ts` — ESM + CJS, dts
- `vitest.config.ts` — if needed (or rely on workspace root)

#### 2.2 Protocol Constants

Define as `as const` objects (not TypeScript enums):

```typescript
const PROTOCOL_VERSION = 1;

const MessageType = {
  ClientHello: 1,
  RegisterTree: 2,
  RemoveTree: 3,
  TickBatch: 4,
  TreeUpdate: 5,
  CommandAck: 6,
  ServerHello: 50,
  Command: 51,
} as const;

const CommandType = {
  EnableStreaming: 'enable-streaming',
  DisableStreaming: 'disable-streaming',
  EnableStateTrace: 'enable-state-trace',
  DisableStateTrace: 'disable-state-trace',
  EnableProfiling: 'enable-profiling',
  DisableProfiling: 'disable-profiling',
} as const;
```

#### 2.3 Message Type Definitions

TypeScript interfaces for every message in the catalog, all sharing a common envelope shape `{ v: number, type: MessageType }`:

- **Agent → Server**: `ClientHelloMessage`, `RegisterTreeMessage`, `RemoveTreeMessage`, `TickBatchMessage`, `TreeUpdateMessage`, `CommandAckMessage`
- **Server → Agent**: `ServerHelloMessage`, `CommandMessage`
- **Discriminated unions**: `AgentToServerMessage`, `ServerToAgentMessage`

Message payloads reference `TickRecord` and `SerializableNode` from `@behavior-tree-ist/core`.

#### 2.4 Validation Utilities

- `isValidTreeId(treeId: string): boolean` — validates against `^[A-Za-z0-9_-]+$`
- `assertValidTreeId(treeId: string): void` — throws with descriptive message on invalid

### Files to Create

| File | Purpose |
|------|---------|
| `packages/studio-transport/package.json` | Package manifest |
| `packages/studio-transport/tsconfig.json` | TypeScript config |
| `packages/studio-transport/tsup.config.ts` | Build config |
| `packages/studio-transport/src/index.ts` | Public API barrel export |
| `packages/studio-transport/src/protocol/types.ts` | All message types, constants, enums |
| `packages/studio-transport/src/protocol/validation.ts` | `isValidTreeId`, `assertValidTreeId` |
| `packages/studio-transport/src/protocol/index.ts` | Protocol barrel export |

### Files to Modify

| File | Changes |
|------|---------|
| Root `package.json` | Add `studio-transport` to build/typecheck/lint scripts |

### Tests to Write

In `packages/studio-transport/src/protocol/validation.test.ts`:

- `isValidTreeId` accepts: `"my-tree"`, `"tree_1"`, `"AbC123"`, `"a"`, `"A-B_c-1"`
- `isValidTreeId` rejects: `"tree with space"`, `"tree.dot"`, `""`, `"tree/slash"`, `"tree@at"`, `"café"`

### Verification

```bash
yarn test packages/studio-transport/
yarn typecheck
yarn lint
```

---

## Phase 3: Transport Abstraction & TreeRegistry

- [ ] **Completed**

### Goal

Define the transport-agnostic `Transport` interface and implement `TreeRegistry` — the client-side registry for trees participating in Studio debugging.

### What to Implement

#### 3.1 Transport Interface

```typescript
interface Transport {
  send(data: string): void;
  onMessage(handler: (data: string) => void): Unsubscribe;
  onOpen(handler: () => void): Unsubscribe;
  onClose(handler: () => void): Unsubscribe;
  close(): void;
  readonly isConnected: boolean;
}
type Unsubscribe = () => void;
```

The interface operates on raw strings (JSON). Serialization/deserialization happens in the `StudioAgent` layer, keeping the transport truly agnostic.

#### 3.2 TreeRegistry

**Constructor**: `new TreeRegistry()`

**Public API**:
- `register(treeId: string, tree: BehaviourTree, options?: { streaming?: boolean }): void`
  - Validates `treeId` format via `assertValidTreeId()`
  - Enforces `treeId` uniqueness within this registry instance
  - Calls `tree.useNowAsTickId()` as part of registration
  - Stores `{ treeId, tree, streaming: options?.streaming ?? false }`
  - Captures initial serialized tree snapshot + computes hash
  - Emits `tree-registered` event
- `remove(treeId: string): void`
  - Removes tree from registry
  - Emits `tree-removed` event
- `get(treeId: string): RegisteredTree | undefined`
- `getAll(): ReadonlyMap<string, RegisteredTree>`
- `enableStreaming(treeId: string): void` / `disableStreaming(treeId: string): void`
- `isStreaming(treeId: string): boolean`

**Event Subscriptions** (simple callback pattern):
- `onTreeRegistered(handler: (entry: RegisteredTree) => void): Unsubscribe`
- `onTreeRemoved(handler: (treeId: string) => void): Unsubscribe`
- `onTick(handler: (treeId: string, record: TickRecord) => void): Unsubscribe`

**Tick Interception**:
The registry needs to know when a registered tree is ticked. Design choice — the registry wraps the tick flow so that after `tree.tick({now})` is called by the integrator, the resulting `TickRecord` is emitted via the `onTick` event. Two approaches:

- **(A) Proxy approach**: Registry provides a `tick(treeId, {now})` method that calls `tree.tick()` internally and emits the event.
- **(B) Post-tick hook**: Integrator calls `tree.tick()` directly and then calls `registry.reportTick(treeId, record)`.

**Recommendation**: **(B)** — keeps the registry non-invasive. The integrator keeps their existing tick loop and adds one line. The `StudioAgent` convenience wrapper can simplify this further.

**RegisteredTree type**:
```typescript
interface RegisteredTree {
  treeId: string;
  tree: BehaviourTree;
  streaming: boolean;
  serializedTree: SerializableNode;
  serializedTreeHash: string;
}
```

### Files to Create

| File | Purpose |
|------|---------|
| `packages/studio-transport/src/transport/types.ts` | `Transport` interface, `Unsubscribe` type |
| `packages/studio-transport/src/registry/tree-registry.ts` | `TreeRegistry` class |
| `packages/studio-transport/src/registry/types.ts` | `RegisteredTree`, `TreeRegistryOptions` |
| `packages/studio-transport/src/registry/index.ts` | Barrel export |
| `packages/studio-transport/src/transport/index.ts` | Barrel export |

### Tests to Write

In `packages/studio-transport/src/registry/tree-registry.test.ts`:

- Register with valid treeId succeeds, entry is retrievable
- Register with invalid treeId throws
- Register with duplicate treeId throws
- Remove registered tree succeeds
- Remove unregistered treeId throws
- `onTreeRegistered` callback fires on register
- `onTreeRemoved` callback fires on remove
- `onTick` callback fires when `reportTick()` is called
- `useNowAsTickId()` is called on the tree during registration
- Default streaming state is `false`
- `enableStreaming`/`disableStreaming` toggles work
- Unsubscribe stops callbacks
- `getAll()` returns all registered trees

### Verification

```bash
yarn test packages/studio-transport/
yarn typecheck
```

---

## Phase 4: StudioAgent

- [ ] **Completed**

### Goal

Implement `StudioAgent` — the client-side class that bridges `TreeRegistry` events to the server transport. No internal timers; user drives periodic work via `agent.tick({now})`.

### What to Implement

#### 4.1 OutboundQueue

A bounded FIFO queue with oldest-eviction:

```typescript
class OutboundQueue<T> {
  constructor(capacity: number)
  push(item: T): void        // Evicts oldest if at capacity
  drain(): T[]                // Returns all items and empties queue
  readonly size: number
  readonly capacity: number
}
```

#### 4.2 StudioAgent

**Constructor**: `new StudioAgent(clientId: string, registry: TreeRegistry, options?: StudioAgentOptions)`

```typescript
interface StudioAgentOptions {
  queueCapacity?: number;     // Default: 1000
}
```

**Public API**:
- `connect(transport: Transport): void`
  - Stores transport reference
  - Subscribes to `transport.onMessage` for inbound server messages
  - On transport open: sends `ClientHello`, then sends `RegisterTree` for each already-registered tree
  - Subscribes to registry events: `onTreeRegistered`, `onTreeRemoved`, `onTick`
- `disconnect(): void`
  - Unsubscribes from all events
  - Closes transport
- `tick(ctx: { now: number }): void`
  - Flushes outbound queue: drains all messages and sends them via transport
  - This is the only periodic entry point — no `setInterval`/`setTimeout`
- `readonly isConnected: boolean`

**Inbound Message Handling** (from server):
- `ServerHello`: No-op (connection confirmed)
- `Command`: Dispatches to target tree based on `treeId` and `command`:
  - `enable-streaming` → `registry.enableStreaming(treeId)`
  - `disable-streaming` → `registry.disableStreaming(treeId)`
  - `enable-state-trace` → `tree.enableStateTrace()`
  - `disable-state-trace` → `tree.disableStateTrace()`
  - `enable-profiling` → `tree.enableProfiling()` (cached provider)
  - `disable-profiling` → `tree.disableProfiling()`
  - Sends `CommandAck` with `success: true` or `success: false` + error details

**Outbound Message Handling**:
- On tree registered (while connected): queue `RegisterTree` message
- On tree removed (while connected): queue `RemoveTree` message
- On tick event: **only if streaming is enabled** for that tree, queue `TickBatch` message. Otherwise, drop silently.
- On tree structure change (serialized hash changed): queue `TreeUpdate` message
- All outbound messages go through the `OutboundQueue`. When queue is full, oldest item is evicted.

**Serialization**: Agent serializes messages to JSON string before calling `transport.send()`. Deserializes inbound JSON from `transport.onMessage`.

### Files to Create

| File | Purpose |
|------|---------|
| `packages/studio-transport/src/agent/outbound-queue.ts` | Bounded FIFO queue |
| `packages/studio-transport/src/agent/studio-agent.ts` | `StudioAgent` class |
| `packages/studio-transport/src/agent/types.ts` | `StudioAgentOptions` |
| `packages/studio-transport/src/agent/index.ts` | Barrel export |

### Tests to Write

In `packages/studio-transport/src/agent/outbound-queue.test.ts`:
- Push within capacity retains all items
- Push at capacity evicts oldest
- Drain returns all items in FIFO order and empties queue
- Size tracks correctly

In `packages/studio-transport/src/agent/studio-agent.test.ts` (using a mock Transport):
- Sends `ClientHello` on transport open
- Sends `RegisterTree` for existing registry entries on connect
- Sends `RegisterTree` when tree is registered after connect
- Sends `RemoveTree` when tree is removed
- Only sends `TickBatch` when streaming is enabled for the tree
- Does NOT send `TickBatch` when streaming is disabled (drops tick)
- `tick()` flushes queued messages through transport
- Handles `Command` → `enable-streaming`: streaming enabled on registry, `CommandAck` sent with `success: true`
- Handles `Command` → `disable-streaming`: streaming disabled, ack sent
- Handles `Command` → `enable-state-trace` / `disable-state-trace`: calls tree methods, ack sent
- Handles `Command` → `enable-profiling` / `disable-profiling`: calls tree methods, ack sent
- Command for unknown tree sends `CommandAck` with `success: false` and error
- Backpressure: when queue is full, oldest message is evicted
- No `setInterval` or `setTimeout` usage in implementation

### Verification

```bash
yarn test packages/studio-transport/
yarn typecheck
yarn lint
```

---

## Phase 5: WebSocket Transport Implementation

- [ ] **Completed**

### Goal

Implement the canonical WebSocket transport that satisfies the `Transport` interface from Phase 3.

### What to Implement

#### 5.1 WebSocketTransport

```typescript
class WebSocketTransport implements Transport {
  constructor(url: string, options?: WebSocketTransportOptions)
  send(data: string): void
  onMessage(handler: (data: string) => void): Unsubscribe
  onOpen(handler: () => void): Unsubscribe
  onClose(handler: () => void): Unsubscribe
  close(): void
  get isConnected(): boolean
}

interface WebSocketTransportOptions {
  reconnectDelayMs?: number;       // Default: 1000
  maxReconnectDelayMs?: number;    // Default: 30000
  WebSocketImpl?: typeof WebSocket; // For dependency injection in tests / custom runtimes
}
```

**Behavior**:
- Uses the standard `WebSocket` API (browser-compatible; in Node.js use the `ws` package)
- Accepts a `WebSocketImpl` constructor for testability and constrained runtimes
- Auto-reconnect with exponential backoff on disconnect
- `close()` cancels reconnect and closes socket
- `send()` when disconnected: silently drops (agent's queue handles buffering)

### Files to Create

| File | Purpose |
|------|---------|
| `packages/studio-transport/src/transport/websocket-transport.ts` | `WebSocketTransport` class |

### Files to Modify

| File | Changes |
|------|---------|
| `packages/studio-transport/src/transport/index.ts` | Export `WebSocketTransport` |
| `packages/studio-transport/src/index.ts` | Export transport module |

### Tests to Write

In `packages/studio-transport/src/transport/websocket-transport.test.ts`:
- Uses injected `WebSocketImpl` for testing (mock WebSocket class)
- `send()` calls `ws.send()` with the raw string
- `onMessage` handler fires when ws receives a message
- `onOpen` handler fires when ws connects
- `onClose` handler fires when ws disconnects
- `isConnected` reflects connection state
- `close()` closes the socket and stops reconnect
- Reconnect fires after configured delay on unexpected close

### Verification

```bash
yarn test packages/studio-transport/
yarn typecheck
```

---

## Phase 6: Server Domain Layer

- [ ] **Completed**

### Goal

Implement the transport-agnostic business logic layer of the Studio server following onion architecture. The domain layer defines interfaces (ports) that infrastructure and app layers implement/consume.

### What to Implement

#### 6.1 Domain Types

```typescript
interface Client {
  clientId: string;
  isOnline: boolean;
  connectedAt: number | undefined;
  disconnectedAt: number | undefined;
}

interface StoredTree {
  clientId: string;
  treeId: string;
  serializedTree: SerializableNode;
  hash: string;
  registeredAt: number;
}

interface ServerSettings {
  maxTickRecordsPerTree: number;  // Default: 10000
}
```

#### 6.2 Domain Interfaces (Ports)

```typescript
interface ClientRepository {
  upsert(client: Client): void;
  findById(clientId: string): Client | undefined;
  findAll(): Client[];
  delete(clientId: string): void;
  setOnline(clientId: string, isOnline: boolean, timestamp: number): void;
}

interface TreeRepository {
  upsert(clientId: string, treeId: string, serializedTree: SerializableNode, hash: string): StoredTree;
  find(clientId: string, treeId: string): StoredTree | undefined;
  findByClient(clientId: string): StoredTree[];
  delete(clientId: string, treeId: string): void;
  deleteByClient(clientId: string): void;
}

interface TickRepository {
  push(clientId: string, treeId: string, records: TickRecord[]): void;
  query(clientId: string, treeId: string, afterTickId?: number, limit?: number): TickRecord[];
  clearByTree(clientId: string, treeId: string): void;
  clearByClient(clientId: string): void;
}

interface SettingsRepository {
  get(): ServerSettings;
  update(settings: Partial<ServerSettings>): ServerSettings;
}

interface AgentGateway {
  sendCommand(clientId: string, correlationId: string, command: string, treeId: string): Promise<void>;
  onCommandAck(handler: (ack: CommandAckPayload) => void): Unsubscribe;
}
```

#### 6.3 Domain Errors

```typescript
class ClientNotFoundError extends Error { ... }
class TreeNotFoundError extends Error { ... }
class ClientOfflineError extends Error { ... }
```

#### 6.4 Hash Utility

Stable hash computation from serialized tree: `computeTreeHash(serializedTree: SerializableNode): string`

Use a simple deterministic string hash of `JSON.stringify(serializedTree)` — no cryptographic requirements for V1.

#### 6.5 StudioService

Central domain service that all app-layer handlers call:

- `handleClientHello(clientId: string, now: number): void` — upsert client as online
- `handleClientDisconnect(clientId: string, now: number): void` — mark offline
- `handleRegisterTree(clientId: string, treeId: string, serializedTree: SerializableNode): void` — hash comparison, conditional tick clear
- `handleRemoveTree(clientId: string, treeId: string): void` — delete tree + ticks
- `handleTickBatch(clientId: string, treeId: string, ticks: TickRecord[]): void` — push to tick repository
- `listClients(): Client[]`
- `listTrees(clientId: string): StoredTree[]`
- `getTree(clientId: string, treeId: string): StoredTree`
- `getTicks(clientId: string, treeId: string, afterTickId?: number, limit?: number): TickRecord[]`
- `getSettings(): ServerSettings`
- `updateSettings(settings: Partial<ServerSettings>): ServerSettings`
- `sendCommand(clientId: string, treeId: string, command: string, correlationId: string): Promise<void>` — validates client is online, forwards via `AgentGateway`
- `deleteClient(clientId: string): void` — hard delete: client + all trees + all ticks

### Files to Create

| File | Purpose |
|------|---------|
| `packages/studio/src/server/domain/types.ts` | `Client`, `StoredTree`, `ServerSettings` |
| `packages/studio/src/server/domain/interfaces.ts` | Repository + gateway interfaces |
| `packages/studio/src/server/domain/errors.ts` | Domain error classes |
| `packages/studio/src/server/domain/hash.ts` | `computeTreeHash()` |
| `packages/studio/src/server/domain/studio-service.ts` | `StudioService` class |
| `packages/studio/src/server/domain/index.ts` | Barrel export |

### Tests to Write

In `packages/studio/src/server/domain/studio-service.test.ts` (using simple in-memory stubs of interfaces):
- `handleClientHello` creates client, marks online
- `handleClientHello` for existing client updates online status
- `handleClientDisconnect` marks client offline, sets `disconnectedAt`
- `handleRegisterTree` — first registration stores tree
- `handleRegisterTree` — upsert with same hash keeps existing tick history
- `handleRegisterTree` — upsert with different hash clears tick history
- `handleRemoveTree` — deletes tree and clears ticks
- `handleTickBatch` — stores tick records
- `getTicks` with `afterTickId` returns only ticks with `tickId > afterTickId`, ascending
- `getTicks` with `limit` respects the limit
- `getTicks` with `afterTickId` older than retained history returns available ticks
- `deleteClient` — hard-deletes client + trees + ticks
- `sendCommand` — throws `ClientOfflineError` when client is offline
- `sendCommand` — forwards command via `AgentGateway` when client is online

In `packages/studio/src/server/domain/hash.test.ts`:
- Same serialized tree produces same hash
- Different serialized tree produces different hash
- Hash is deterministic (no randomness)

### Verification

```bash
yarn test packages/studio/src/server/domain/
yarn typecheck
```

---

## Phase 7: Server Infrastructure Layer (In-Memory Repositories)

- [ ] **Completed**

### Goal

Implement the in-memory repository classes that satisfy the domain interfaces from Phase 6.

### What to Implement

#### 7.1 InMemoryClientRepository

- `Map<string, Client>` storage
- All operations are synchronous (in-memory)

#### 7.2 InMemoryTreeRepository

- `Map<string, Map<string, StoredTree>>` — keyed by `clientId` then `treeId`

#### 7.3 InMemoryTickRepository

- Ring buffer per `(clientId, treeId)` key
- Maximum capacity sourced from `SettingsRepository.get().maxTickRecordsPerTree`
- `query()` implements the `afterTickId` cursor: binary search or linear scan since ticks are stored in insertion order (ascending `tickId`)
- `push()` evicts oldest when at capacity

#### 7.4 InMemorySettingsRepository

- Single `ServerSettings` object
- Default: `{ maxTickRecordsPerTree: 10000 }`

### Files to Create

| File | Purpose |
|------|---------|
| `packages/studio/src/server/infrastructure/in-memory-client-repository.ts` | Client storage |
| `packages/studio/src/server/infrastructure/in-memory-tree-repository.ts` | Tree storage |
| `packages/studio/src/server/infrastructure/in-memory-tick-repository.ts` | Tick ring buffer storage |
| `packages/studio/src/server/infrastructure/in-memory-settings-repository.ts` | Settings storage |
| `packages/studio/src/server/infrastructure/index.ts` | Barrel export |

### Tests to Write

In `packages/studio/src/server/infrastructure/in-memory-client-repository.test.ts`:
- Upsert creates new client
- Upsert updates existing client
- `findById` returns undefined for missing client
- `findAll` returns all clients
- `delete` removes client
- `setOnline` updates online status and timestamp

In `packages/studio/src/server/infrastructure/in-memory-tree-repository.test.ts`:
- Upsert creates tree
- Upsert replaces tree with same key
- `findByClient` returns all trees for a client
- `delete` removes specific tree
- `deleteByClient` removes all trees for a client

In `packages/studio/src/server/infrastructure/in-memory-tick-repository.test.ts`:
- Push stores records retrievable via query
- Ring buffer eviction: push beyond capacity evicts oldest
- `query` with `afterTickId` returns only newer ticks (exclusive lower bound)
- `query` with `limit` caps results
- `query` returns ticks in ascending `tickId` order
- `query` with `afterTickId` older than retained: returns whatever is available
- `clearByTree` removes ticks for specific tree
- `clearByClient` removes ticks for all trees of a client

In `packages/studio/src/server/infrastructure/in-memory-settings-repository.test.ts`:
- Returns defaults on first `get()`
- `update` merges partial settings
- `get` returns updated values after `update`

### Verification

```bash
yarn test packages/studio/src/server/infrastructure/
yarn typecheck
```

---

## Phase 8: Server App Layer (tRPC + WebSocket Handlers)

- [ ] **Completed**

### Goal

Wire up the HTTP API (tRPC) and WebSocket agent connection handler. Compose domain service with infrastructure to create the full server.

### What to Implement

#### 8.1 tRPC Router

All procedures are standard HTTP endpoints (GET for queries, POST for mutations), fully curl-able.

**Query procedures (GET)**:
- `listClients` → `StudioService.listClients()`
- `listTrees` → input: `{ clientId }` → `StudioService.listTrees(clientId)`
- `getTree` → input: `{ clientId, treeId }` → `StudioService.getTree(clientId, treeId)`
- `getTicks` → input: `{ clientId, treeId, afterTickId?, limit? }` → `StudioService.getTicks(...)`
- `getSettings` → `StudioService.getSettings()`

**Mutation procedures (POST)**:
- `updateSettings` → input: `{ maxTickRecordsPerTree? }` → `StudioService.updateSettings(...)`
- `sendCommand` → input: `{ clientId, treeId, command }` → generates `correlationId`, calls `StudioService.sendCommand(...)`, waits for ack, returns result
- `deleteClient` → input: `{ clientId }` → `StudioService.deleteClient(...)`

Input validation via `zod` schemas.

#### 8.2 WebSocket Agent Handler

Manages agent WebSocket connections:
- On connection: wait for `ClientHello` message
- On `ClientHello`: call `StudioService.handleClientHello()`, send `ServerHello` response
- On `RegisterTree`: call `StudioService.handleRegisterTree()`
- On `RemoveTree`: call `StudioService.handleRemoveTree()`
- On `TickBatch`: call `StudioService.handleTickBatch()`
- On `TreeUpdate`: call `StudioService.handleRegisterTree()` (upsert)
- On `CommandAck`: resolve pending command correlation
- On disconnect: call `StudioService.handleClientDisconnect()`

Implements `AgentGateway` interface: sends `Command` messages to the appropriate client's WebSocket.

#### 8.3 Server Factory

```typescript
function createStudioServer(options?: StudioServerOptions): StudioServer

interface StudioServerOptions {
  host?: string;          // Default: '127.0.0.1'
  port?: number;          // Default: 3000 (or pick a sensible default)
  wsPort?: number;        // WebSocket port (can be same as HTTP via upgrade)
}

interface StudioServer {
  start(): Promise<{ httpUrl: string; wsUrl: string }>;
  stop(): Promise<void>;
}
```

Composition: instantiates all in-memory repositories, creates `StudioService`, creates tRPC router, creates WebSocket handler, creates HTTP server.

#### 8.4 Static File Serving

Serves the built React UI assets from a `dist/` or `public/` directory for production mode. During development, the Vite dev server serves the UI separately.

### Dependencies to Add

| Package | Purpose |
|---------|---------|
| `@trpc/server` | tRPC server |
| `ws` | WebSocket server (Node.js) |
| `@types/ws` | TypeScript types for ws |
| `zod` | Input validation for tRPC |

Use `@trpc/server/adapters/standalone` or `@trpc/server/adapters/node-http` with Node.js `http` module to minimize framework dependencies.

### Files to Create

| File | Purpose |
|------|---------|
| `packages/studio/src/server/app/trpc-router.ts` | tRPC router definition |
| `packages/studio/src/server/app/trpc-context.ts` | tRPC context creation |
| `packages/studio/src/server/app/websocket-handler.ts` | WebSocket connection handler |
| `packages/studio/src/server/app/agent-gateway.ts` | `AgentGateway` implementation via WebSocket |
| `packages/studio/src/server/app/server.ts` | `createStudioServer` factory |
| `packages/studio/src/server/app/index.ts` | Barrel export |

### Files to Modify

| File | Changes |
|------|---------|
| `packages/studio/package.json` | Add server dependencies: `@trpc/server`, `ws`, `zod` |

### Tests to Write

In `packages/studio/src/server/app/trpc-router.test.ts`:
- `listClients` returns client list
- `listTrees` returns trees for given client
- `getTree` returns specific tree
- `getTicks` with cursor pagination works
- `updateSettings` changes settings
- `deleteClient` removes all client data
- `sendCommand` returns success ack for online client
- `sendCommand` returns error for offline client

In `packages/studio/src/server/app/websocket-handler.test.ts`:
- Processes `ClientHello` and responds with `ServerHello`
- Processes `RegisterTree` → stores tree
- Processes `RemoveTree` → removes tree
- Processes `TickBatch` → stores ticks
- Client disconnect marks client offline
- `Command` forwarding works via `AgentGateway`
- `CommandAck` resolves pending command

### Verification

```bash
yarn test packages/studio/src/server/
yarn typecheck
yarn lint
```

---

## Phase 9: React Component Studio Mode

- [ ] **Completed**

### Goal

Add Studio mode support to `BehaviourTreeDebugger`: empty state (no tree/ticks), optional `studio` prop, and Studio control components.

### What to Implement

#### 9.1 Empty State Support

Make `tree` and `ticks` props optional in `BehaviourTreeDebuggerProps`:
- When no `tree` is provided, render a centered fallback: "No tree selected"
- When `tree` is provided but `ticks` is empty/undefined, render the tree with no tick overlay

#### 9.2 Studio Props

```typescript
interface StudioProps {
  clients: StudioClient[];
  selectedClientId: string | null;
  selectedTreeId: string | null;
  trees: StudioTreeInfo[];
  onSelectClient: (clientId: string) => void;
  onSelectTree: (treeId: string) => void;
  onSendCommand: (command: string, treeId: string) => Promise<StudioCommandResult>;
  streamingEnabled: boolean;
  stateTraceEnabled: boolean;
  profilingEnabled: boolean;
  isClientOnline: boolean;
  isLive: boolean;                // true = receiving fresh data, false = viewing stale/persisted
  onOpenSettings?: () => void;
}

interface StudioClient {
  clientId: string;
  isOnline: boolean;
}

interface StudioTreeInfo {
  treeId: string;
}

interface StudioCommandResult {
  success: boolean;
  errorCode?: string;
  errorMessage?: string;
}
```

Add to `BehaviourTreeDebuggerProps`:
```typescript
studio?: StudioProps;
```

#### 9.3 Studio Toolbar Controls

Rendered **only when `studio` prop is provided**:
- **Client/tree selector**: dropdown or panel for picking client and tree
- **Streaming play/pause toggle**: sends `enable-streaming` / `disable-streaming` command
- **State trace toggle**: sends `enable-state-trace` / `disable-state-trace`
- **Profiling toggle**: sends `enable-profiling` / `disable-profiling`
- **Online/offline indicator**: visual status for attached client
- **Live/stale indicator**: shows if data is fresh or from a disconnected client
- **Settings button**: calls `onOpenSettings`

**Optimistic toggle behavior**: clicking a toggle immediately shows the pending state. On error ack, reverts and surfaces error feedback.

#### 9.4 Backward Compatibility

- When `studio` prop is absent, **zero** Studio UI renders — behavior is identical to current
- Existing `toolbarActions` still works independently of `studio` prop

### Files to Modify

| File | Changes |
|------|---------|
| `packages/react/src/types.ts` | Make `tree`/`ticks` optional, add `StudioProps` and related types, add `studio` to `BehaviourTreeDebuggerProps` |
| `packages/react/src/BehaviourTreeDebugger.tsx` | Handle optional tree/ticks, render empty state, render Studio controls when `studio` prop present |
| `packages/react/src/index.ts` | Export `StudioProps`, `StudioClient`, `StudioTreeInfo`, `StudioCommandResult` |

### Files to Create

| File | Purpose |
|------|---------|
| `packages/react/src/components/studio/StudioToolbar.tsx` | Studio toolbar controls (toggles, indicators) |
| `packages/react/src/components/studio/ClientTreeSelector.tsx` | Client/tree picker component |
| `packages/react/src/components/studio/EmptyState.tsx` | "No tree selected" fallback |
| `packages/react/src/components/studio/index.ts` | Barrel export |

### Tests to Write

In `packages/react/src/__tests__/studio-mode.test.tsx`:
- Renders "No tree selected" when `tree` prop is undefined
- Studio controls are hidden when `studio` prop is absent
- Studio controls are visible when `studio` prop is provided
- Existing debugger usage (with `tree` + `ticks`, no `studio`) works unchanged
- Toggle buttons call `onSendCommand` with correct command
- Online/offline indicator reflects `isClientOnline`
- Client/tree selector calls `onSelectClient`/`onSelectTree`

### Verification

```bash
yarn test packages/react/
yarn build
yarn typecheck
```

---

## Phase 10: Studio UI Wiring (Polling, State Management, Local Persistence)

- [ ] **Completed**

### Goal

Build the Studio application shell that connects `BehaviourTreeDebugger` (with `studio` prop) to the server via HTTP polling.

### What to Implement

#### 10.1 tRPC Client Setup

Create a tRPC client configured to call the Studio server. Type-safe using the router type from Phase 8.

Add dependency: `@trpc/client`.

#### 10.2 Polling Hooks

`useStudioPolling(trpcClient, options)`:
- Polls `listClients` and `listTrees` at configurable interval (default `200ms`)
- Polls `getTicks` with `afterTickId` cursor for incremental tick fetching
- Default tick fetch limit: `200`
- Accumulates ticks into local state (bounded by local TickStore capacity)
- Resets cursor when selected client/tree changes

#### 10.3 State Management

React state for:
- `selectedClientId` / `selectedTreeId`
- Fetched `serializedTree` and accumulated `ticks`
- Toggle states (`streaming`, `stateTrace`, `profiling`) — derived from command ack round-trips
- Server settings
- Client list with online/offline status

#### 10.4 Command Dispatching

`useStudioCommands(trpcClient)`:
- `sendCommand(clientId, treeId, command)` → calls `sendCommand` mutation, returns ack result
- Handles optimistic updates and rollback

#### 10.5 Local Persistence (localStorage)

`useLocalPersistence(key, defaultValue, schema?)`:
- Save/restore: `selectedClientId`, `selectedTreeId`, `pollingInterval`, `tickFetchLimit`, `themeMode`, `localTickStoreCapacity`
- Robust to corrupted localStorage, schema changes, and stale values
- Falls back to defaults on any parse error

#### 10.6 Studio App Component

Rewrite `App.tsx` to compose:
1. tRPC client
2. Polling hooks
3. State management
4. `BehaviourTreeDebugger` with `studio` prop fully wired
5. Settings panel/drawer

#### 10.7 Settings Panel

UI for:
- Server settings: `maxTickRecordsPerTree`
- Local settings: polling interval, tick fetch limit, local TickStore capacity

### Files to Create

| File | Purpose |
|------|---------|
| `packages/studio/src/ui/trpc-client.ts` | tRPC client setup |
| `packages/studio/src/ui/hooks/useStudioPolling.ts` | Polling logic |
| `packages/studio/src/ui/hooks/useStudioCommands.ts` | Command dispatch |
| `packages/studio/src/ui/hooks/useLocalPersistence.ts` | localStorage persistence |
| `packages/studio/src/ui/components/SettingsPanel.tsx` | Settings drawer/panel |
| `packages/studio/src/ui/StudioApp.tsx` | Main Studio app component |

### Files to Modify

| File | Changes |
|------|---------|
| `packages/studio/src/App.tsx` | Rewrite to use `StudioApp` |
| `packages/studio/src/main.tsx` | Update entry point if needed |
| `packages/studio/package.json` | Add `@trpc/client` dependency |

### Tests to Write

In `packages/studio/src/ui/hooks/useLocalPersistence.test.ts`:
- Saves values to localStorage
- Restores values on mount
- Falls back to defaults on corrupted localStorage
- Falls back to defaults on schema mismatch

### Verification

```bash
yarn test packages/studio/
yarn typecheck
```

Manual verification:
- Start server (Phase 8), start UI dev server
- UI shows client list, tree list
- Selecting a client/tree shows the debugger
- Toggle commands round-trip through server

---

## Phase 11: CLI Entrypoint

- [ ] **Completed**

### Goal

Create a CLI that starts server, UI, and optional mock client processes with graceful shutdown.

### What to Implement

#### 11.1 Argument Parsing

Flags:
- `--server` — start the HTTP/WebSocket server
- `--ui` — start the Vite dev server (dev) or serve built assets (production)
- `--mock-client` — start a mock client process
- `--demo` — shorthand for `--server --ui --mock-client`
- `--host <host>` — bind host (default `127.0.0.1`)
- `--port <port>` — server port
- `--ui-port <port>` — UI port

**Default**: no flags → `--server --ui`.

Use a lightweight arg parser (e.g., `yargs`, `commander`, or manual `process.argv` parsing).

#### 11.2 Mock Client

Reuses the existing `heavy-profiler-demo-tree.ts`:
- Creates a `TreeRegistry` and `StudioAgent`
- Registers the demo tree
- Connects via `WebSocketTransport` to the server
- Ticks the tree + agent on a `setInterval` (acceptable for mock client; agent itself has no timers)
- Enables streaming for the demo tree by default

#### 11.3 Graceful Shutdown

`SIGINT` handler:
- Stops mock client timer
- Disconnects `StudioAgent`
- Stops Studio server
- Exits cleanly

Subprocesses (like Vite dev server) must also be killed.

#### 11.4 Package Configuration

- Add `bin` field to `packages/studio/package.json`: `"studio": "./dist/cli/index.js"` (or use `tsx` for development)
- Add a dev script: `"studio:dev": "tsx src/cli/index.ts"`

### Files to Create

| File | Purpose |
|------|---------|
| `packages/studio/src/cli/index.ts` | CLI entrypoint |
| `packages/studio/src/cli/args.ts` | Argument parsing |
| `packages/studio/src/cli/mock-client.ts` | Mock client using demo tree |
| `packages/studio/src/cli/process-manager.ts` | Starts/stops child processes, SIGINT handling |

### Files to Modify

| File | Changes |
|------|---------|
| `packages/studio/package.json` | Add `bin` field, CLI scripts, dependency on `tsx` for dev |

### Tests to Write

In `packages/studio/src/cli/args.test.ts`:
- No flags defaults to `{ server: true, ui: true, mockClient: false }`
- `--demo` results in `{ server: true, ui: true, mockClient: true }`
- `--server` only: `{ server: true, ui: false, mockClient: false }`
- `--mock-client` only: `{ server: false, ui: false, mockClient: true }`
- `--host` and `--port` parsing
- Combined flags work

### Verification

```bash
yarn test packages/studio/src/cli/
yarn typecheck
```

Manual verification:
```bash
# Default (server + UI)
yarn workspace @behavior-tree-ist/studio studio:dev

# Demo mode
yarn workspace @behavior-tree-ist/studio studio:dev -- --demo

# Server only
yarn workspace @behavior-tree-ist/studio studio:dev -- --server

# Ctrl+C → all processes exit cleanly
```

---

## Phase 12: Integration Testing & Demo Validation

- [ ] **Completed**

### Goal

End-to-end integration tests that validate all acceptance criteria from spec Section 10.3. Final demo validation.

### What to Implement

#### 12.1 Integration Test Infrastructure

Test helper that:
- Starts a real Studio server on a random available port
- Creates a real `StudioAgent` with `WebSocketTransport`
- Provides cleanup/teardown utilities

#### 12.2 Acceptance Criteria Tests (Spec Section 10.3)

**1. Identity/restart**:
- Same `(clientId, treeId)` works across agent disconnect/reconnect
- Duplicate `now`-based `tickId` is rejected at the core level

**2. Polling**:
- UI polling with `afterTickId` returns ticks where `tickId > afterTickId` (exclusive cursor), ordered ascending
- If `afterTickId` is older than retained history, server returns available ticks (no gap error)
- Tick fetch `limit` is respected

**3. Offline retention**:
- Client disconnection marks client as offline; data remains visible via API
- Hard delete via API fully removes all client-scoped data
- `RemoveTree` clears tree metadata and tick history immediately

**4. Tree upsert invalidation**:
- `RegisterTree` with same serialized hash keeps existing tick history
- `RegisterTree` with different serialized hash clears existing tick history

**5. Remote toggles**:
- Successful ack returns `{ success: true }`
- Error ack returns `{ success: false, errorCode, errorMessage }`
- Streaming is off by default until explicitly enabled
- Pausing streaming stops new tick uploads without disconnecting
- Ticks produced while streaming is disabled are not delivered retroactively on re-enable

**6. Debugger empty state**:
- Renders "No tree selected" with no tree/ticks
- Studio controls hidden when `studio` prop absent

**7. Backpressure**:
- Full outbound queue drops oldest unsent records

**8. CLI**:
- Each flag combination starts expected processes
- Ctrl+C exits cleanly

### Files to Create

| File | Purpose |
|------|---------|
| `packages/studio/src/__integration__/test-helpers.ts` | Server/agent test utilities |
| `packages/studio/src/__integration__/identity-restart.test.ts` | Criteria 1 |
| `packages/studio/src/__integration__/polling.test.ts` | Criteria 2 |
| `packages/studio/src/__integration__/offline-retention.test.ts` | Criteria 3 |
| `packages/studio/src/__integration__/tree-upsert.test.ts` | Criteria 4 |
| `packages/studio/src/__integration__/remote-toggles.test.ts` | Criteria 5 |
| `packages/studio/src/__integration__/backpressure.test.ts` | Criteria 7 |

### Verification

```bash
# All tests
yarn test

# All builds
yarn build

# Type checking
yarn typecheck

# Linting
yarn lint

# Manual demo
yarn workspace @behavior-tree-ist/studio studio:dev -- --demo
# → Open browser → see client connected → see tree rendering → toggle controls work
```

---

## Dependency Graph

```
Phase 1   Core Runtime Prerequisites
  │
  ├──► Phase 2   Protocol Types & Package Scaffolding
  │       │
  │       ├──► Phase 3   Transport Abstraction & TreeRegistry
  │       │       │
  │       │       ├──► Phase 4   StudioAgent
  │       │       │       │
  │       │       │       ├──► Phase 5   WebSocket Transport
  │       │       │       │
  │       │       │       └────────────────────────┐
  │       │       │                                │
  │       └───────┼──► Phase 6   Server Domain     │
  │               │       │                        │
  │               │       └──► Phase 7   Server Infra
  │               │               │
  │               │               └──► Phase 8   Server App ◄──┘
  │               │                       │
  │               └──► Phase 9   React Studio Mode
  │                       │               │
  │                       └───────────────┤
  │                                       │
  │                               Phase 10  Studio UI Wiring
  │                                       │
  │                               Phase 11  CLI Entrypoint
  │                                       │
  │                               Phase 12  Integration Tests
```

Phases 5 and 6 can be developed in parallel. Phases 9 and 6-8 can be developed in parallel. All other dependencies are sequential.

---

## Package Dependency Summary

```
@behavior-tree-ist/core                    (modified in Phase 1)
  └─ peer dep ─► @behavior-tree-ist/studio-transport   (new, Phases 2-5)
                  └─ dep ──► @behavior-tree-ist/react   (modified in Phase 9)
                              └─ dep ──► @behavior-tree-ist/studio (modified in Phases 6-12)
```

## Root Script Updates

The root `package.json` build/typecheck/lint scripts need updating to include `studio-transport` in the dependency-ordered chain:

```
build:    core → studio-transport → react → studio
typecheck: core → studio-transport → react → studio
lint:     all packages
```
